# Awelon Object Language (AO)

Awelon Object (AO) language directly uses [Awelon Bytecode (ABC)](AboutABC.md) as a foundation for functional programming. 

AO is very simple. The primary structure is the dictionary, which defines a finite set of words. Definitions are encoded in Awelon Bytecode and may refer to other words in the dictionary via `{%word}` tokens. The meaning of a word token is, trivially, to substitute the word's definition. Dependencies between words form a directed acyclic graph, thus a complete expansion of AO code results in a finite string of bytecode. 

Instead of conventional syntax, AO assumes human developers will use editable views to manipulate dictionary code. Directly reading or writing bytecode would be intolerable, but views can be rich and problem specific. See *Editable Views of Bytecode* and *Dictionary Applications*, below. Views may be implemented by a development environment, a web service, or a FUSE adapter.

## Import/Export

AO specifies a simple **.ao** file format for import and export. 

A trivial example dictionary:

        @swap rwrwzwlwl
        @swapd rw {%swap} wl
        @swapd.doc "x y z -- y x z
         swap just under the top stack element
         assuming typical (stack*ext) environment
        ~l

This is format suitable for simple text files and streams. Each word definition starts at `@` at the beginning of a line, followed by the word, followed by SP or LF, then the definition in ABC. This is unambiguous: ABC never includes `@` at the beginning of a line. A lot of words will use just one line in the file.

There are two additional structural constraints:

* well defined words are listed before use
* words are listed no more than once

These constraints are to simplify stream-processing of a large dictionary, e.g. compiling or typechecking as we go. When we encounter an unlisted word, we know that the word is not well defined (i.e. it's either undefined or part of a cycle). Because words are listed at most once, we don't need to deal with edits and recomputation.

Use file suffix **.ao**, or `text/vnd.org.awelon.aodict` in context of an HTTP transfer. 

## Programmable Views

### Editable Views of AO Bytecode

An example editable view is the [Command Language for Awelon (claw)](CommandLine.md), which provides a Forth-like experience optimized for command-line or REPL oriented programming. Claw supports numbers (integers, ratios, decimals), words, and small texts. For example, `2/3` expands to `2 3 ratio` which ultimately expands to bytecode `#2{%int}#3{%int}{%ratio}`. The expansion is reversible, bi-directional. When reading the generated bytecode through a claw view, the developer will see `2/3`.

It is possible to extend claw with structured programming features. Code of form `[cond] [body] while_do_` could be recognized and presented as a conventional while-do loop. We can take inspiration from XML, problem-specific languages, or something more esoteric. Modeling monadic bindings and DSLs is feasible. For interactive environments or live coding we might be interested in programming with widgets, e.g. `30 slider` might be rendered as a slider widget at 30%. Stateful widgets - sliders, checkboxes, radio buttons, color pickers, canvases, graphs, etc. - are generally a good fit for interactive source code.

Editable views needn't be extensions of claw, of course. Though, for user convenience, it's preferable to make most extensions compatible with a claw view. It's easy enough to use a set of flags to enable or disable certain extensions.

Alternatively, we can move beyond parsing and editing structure within a string of bytecode and focus instead on dictionary-level structures between words. This can allow us to render and manipulate *semantic* content - embedded databases and graphs and objects - rather than local syntactic structure. See *Dictionary Applications and Objects* below.

### Dictionary Applications and Objects

A dictionary application is an application whose state is hosted within a healthy dictionary. This is similar to editable views of bytecode, except it may involve multi-word structures and more flexible computations. Dictionary application state is easily imported, exported, and refactored to discover and abstract common patterns. Dictionary applications have a close relationship to live coding.

Dictionary applications will utilize: 

* conventions for names, types, code structure 
* compilers, caches, indexes for performance
* external services to provide editable views

Code structure includes editable views but extends to conventions that involve multiple words. As an example, a variant on the [command pattern](https://en.wikipedia.org/wiki/Command_pattern) is recommended for modeling 'mutable' objects in a dictionary. Encoded in a dictionary, this pattern looks something like:

        @foo.v0 (construct initial foo)
        @foo.v1 {%foo.v0}(command to update foo)
        @foo.v2 {%foo.v1}(another command to update foo)
        @foo.v3 {%foo.v2}(yet another command to update foo)
        @foo    {%foo.v3}{%fooType}

An 'object' in this case might be a document, a graph, a database, a REPL session, or anything else where updates can reasonably be modeled as a stream of commands. Old versions of the object remain available for history and forking. The commands are logged and available for abstraction. Automatic refactoring might rebase an object or gradually eliminate historical versions that aren't referenced elsewhere. With a good cache, updates to the object might be little more expensive than applying one more command.

The command pattern is simple, flexible, and broadly generic. But one might imagine useful patterns based on append-only threaded forums and mailing lists, mergeable structures, or more conventional memory cell manipulations. In some cases, it might be simple and sufficient to rely on editable views and structured DSLs, with the application directly parsing and editing words. It's up to application architects to find effective ways to encode state in a healthy dictionary.

With dictionary apps, we can expect some dictionaries to grow into rich ecosystems with millions of words modeling thousands of forum threads, edit sessions, wikis, databases, spreadsheets, and more. Quantity has a quality of its own.

## Development 

### Static Analysis

Though ABC doesn't specify a type system, it is designed to support static analysis. An AO dictionary under development should undergo continuous static analysis such that developers are always aware of potential issues - obvious type errors, non-termination, linter warnings, etc..

Static analysis can be greatly extended by use of *annotations*, which may potentially assert properties that would be difficult to express otherwise - e.g. that two blocks are equivalent, or that a function is commutative or associative or idempotent, or that one function is the reverse of another, or that a value should be computed statically.

### Transitory Undefined Words

A dictionary in a transitory state of development will frequently have a few undefined words. These can serve a useful role in the development context: a development environment can recognize undefined words as 'holes'. The rough type or shape for a hole may be inferred from usage context. A good developoment environment could help developers find an implementation. Or, at the very least, the temporary presence of undefined words will simplify top-down development. 

AO doesn't use a 'linker' that operates outside the scope of the dictionary. Undefined words are not externally defined. So, the number of undefined words should generally be limited based on the amount of active development. Undefined words may be listed in warnings or as errors.

### DVCS Based Distribution

PLs today widely use package based distribution models. A package of code includes data types and functions, and may depend on other packages of code, all independently developed and versioned. Package based distribution introduces many complications: version conflicts, configuration management, external configuration languages. These complications hinder efforts to refactor, abstract, test, live-code, model application state in code, etc. across multiple packages. 

AO favors a far more simple and robust technique: a dictionary contains all dependencies, all words defined. DVCS-based forks and merges are readily applied: developers can fork public dictionaries, update as needed, validate changes, and cherry-pick functions or updates to push back upstream atomically. Instead of packaged libraries, every dictionary is a wholistic ecosystem. 

*Aside:* An interesting possibility is genetic programming. Words serve as genes, definitions as alleles. Fitness can be based on typechecking, unit tests, and score annotations within each dictionary. Take a population of dictionaries and use word-level random merges (and rare mutations) to model sexual recombination. This would be expensive, but reasonably straightforward.

### Regarding Large Definitions

Definitions can potentially grow very large, especially when containing embedded texts or with dictionary applications. However, huge definitions are not recommended, as they hinder incremental computations, reuse, memory management. At the moment, I'm not suggesting any hard caps for definition sizes, but raising some warnings or flags for large definitions is recommended.

### Optimizing Dictionaries: Hidden, Opaque, and Frozen Words

Words in an AO dictionary provide a basis for mutable meaningful structure, modularity, and structure sharing. The mutable meaningful structure allows AO dictionaries to serve as a platform for live coding and dictionary applications. 

Unfortunately, the presence of mutable meaningful structure interferes with direct optimization at the dictionary layer. This isn't a major problem: a compiler could maintain a cache of optimized definitions separate from the dictionary. But there are some opportunity costs with respect to separating the optimizer, redistributing optimized code, and generalizing automatic  management of dictionary applications. 

To recover the lost opportunities, we can enable developers and dictionary applications to *declaratively relax* the constraints on the optimizer for useful subsets of the dictionary. I propose the following:

* A word may be declared **hidden** to relax the requirement for stable external reference. An optimizer is free to delete a hidden word if it has no clients. This enables garbage collection of dictionaries.
* A word may be declared **opaque** to relax the requirement for stable structure of its definition. An optimizer is free to rearrange, refactor, or reorganize the definition of an opaque word in ways that preserve its behavior. 
* A word may be declared **frozen** to relax the requirement for mutable behavior. An optimizer is free to inline definition of a *frozen* word into the definition of an *opaque* word. A frozen word is *deep-frozen* if all transitive dependencies are also frozen.

To declare a list of attributes, I propose prefixing any definition as follows:

        [{&hidden}{&opaque}{&frozen}]%

This structure is easily preserved on export, easily recognized and handled by optimizers, and trivially eliminated when simplifying code. It's extensible with new attributes (categories, relations, etc.). A reverse token lookup index will efficiently find all words with a given attribute. The main disadvantage is that it's a bit noisy.

Note: These attributes only affect a dictionary optimizer. The *frozen* attribute is not a security attribute. If a developer wants to modify the definition for a frozen word, he can do so. Though, a development environment might require explicitly un-freezing the word to modify its behavior.

## Constraints on Words and Definitions

Words are constrained to be friendly in context of URLs, English text delimiters, and HTML. Tokens are constrained for purity and portability. Texts are constrained to avoid conversion errors (e.g. HTML CRLF conversions, or UTF-8 vs. UTF-16). 

Summary of constraints:

* words are limited to:
 * ASCII if alphabetical, numeral, or in -._~!$'*+:@
 * other UTF-8 except for C1, surrogates, replacement char
 * must not start with a digit or +-. followed by a digit
 * must not end with a . (dot or period)
 * no empty words or enormous words. 1..64 bytes UTF-8.
* tokens are limited to:
 * word dependencies (`{%dupd}{%swap}`)
 * discretionary value sealer (`{:foo}`)
 * discretionary value unsealer (`{.foo}`)
 * annotations (`{&static}{&copyable}`)
 * token modulo prefix is valid word
* texts are limited to:
 * exclude C0 (except LF), DEL, C1
 * exclude surrogate codepoints U+D800..U+DFFF
 * exclude replacement char U+FFFD
