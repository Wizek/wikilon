# Awelon Object Language (AO)

Awelon Object (AO) language directly uses [Awelon Bytecode (ABC)](AboutABC.md) as a foundation for functional programming. 

AO is very simple. The primary structure is the dictionary, which defines a finite set of words. Definitions are encoded in bytecode and may refer to other words in the dictionary with `{%word}` tokens. Dependencies between words must form a directed acyclic graph. The meaning of every `{%word}` token is, trivially, to substitute the word's definition. 

Directly reading or writing bytecode would be intolerable. AO assumes developers use editable views (lenses) to manipulate dictionary code. See *Editable Views of Bytecode* and *Dictionary Applications*, below. Views can be implemented by a development environment or a virtual filesystem (e.g. via FUSE).

## Import/Export

AO specifies a simple **.ao** file format for import and export. 

An example dictionary:

        @swap rwrwzwlwl
        @swapd rw {%swap} wl
        @swapd.doc "x y z -- y x z
         swap just under the top stack element
         assuming typical (stack*ext) environment
        ~l

This is format suitable for simple text files and streams. Each word definition starts at `@` at the beginning of a line, followed by the word, followed by SP or LF, then the definition in ABC. This is unambiguous: ABC never includes `@` at the beginning of a line. A lot of words will use just one line in the file.

There are two additional structural constraints:

* well defined words are listed before use
* words are listed no more than once

These constraints are to simplify stream-processing of a large dictionary, e.g. compiling or typechecking as we go. When we encounter an unlisted word, we know that the word is not well defined (i.e. it's either undefined or part of a cycle). Because words are listed at most once, we don't need to deal with edits and recomputation.

Use file suffix **.ao**, or `text/vnd.org.awelon.aodict` in context of an HTTP transfer. 

## Programmable Views

### Editable Views of Bytecode

An example editable view is the [Command Language for Awelon (claw)](CommandLine.md), which provides a Forth-like experience optimized for command-line or REPL oriented programming. Claw supports numbers (integers, ratios, decimals), words, and small texts. For example, `2/3` expands to `2 3 ratio` which ultimately expands to bytecode `#2{%integer}#3{%integer}{%ratio}`. The expansion is reversible, bi-directional. When reading the generated bytecode through a claw view, the developer will see `2/3`.

It is easy to extend claw with structured programming features. Code of form `[cond] [body] while-do` could be recognized and presented as a conventional while loop; same for if-then expressions. A structure like `{a,b,c}` might trivially expand to `lbrace a comma b comma c rbrace`, convenient for building lists or other sequential structures. Monadic bindings are feasible, perhaps building on lists. For interactive environments or live coding we might be interested in programming with widgets. `30 slider` could be rendered as a slider widget at 30%. Stateful widgets - sliders, checkboxes, radio buttons, color pickers, canvases, graphs, etc. - are generally a good fit for interactive source code.

Alternatively, we ignore claw and take inspiration from elsewhere, or develop something problem-specific. Though, if we need a lot of structured manipulation, or if we want to render and manipulate evaluated content, we should represent this instead as a *Dictionary Application* (see below).

### Dictionary Applications

A dictionary application is an application whose state is hosted within a healthy dictionary. This is similar to editable views of bytecode, except it may involve multi-word structures and more flexible computations. Dictionary application state is easily imported, exported, and refactored to discover and abstract common patterns. Dictionary applications have a close relationship to live coding.

Dictionary applications will utilize: 

* conventions for names, types, code structure 
* compilers, caches, indexes for performance
* external services to provide editable views

As an example convention for code structure: the [command pattern](https://en.wikipedia.org/wiki/Command_pattern) is recommended for modeling most 'mutable' objects in a dictionary. Encoded in a dictionary, this pattern will look something like:

        @object:foo.v0 (construct initial foo)
        @object:foo.v1 {%object:foo.v0}(command to update foo)
        @object:foo.v2 {%object:foo.v1}(another command to update foo)
        @object:foo.v3 {%object:foo.v2}(yet another command to update foo)
        @object:foo {%object:foo.v3}

The 'object' in question might model be a database, a document, a graph, a REPL session, or similar. Information held by the object is manipulated by commands. A service might compute, cache, and render a value or type for the object. We could render historical versions of the object. We can also fork the object and model multiple alternative evolutions. Commands remain available for abstraction and refactoring, and definitions are mostly reasonably sized. It is feasible to automatically refactor and eliminate intermediate object versions (e.g. by concatenating and optimizing commands), if later we must recover some space. But keeping definitions relatively small has its own advantages.

Some applications are characterized primarily by appending content, or make heavy use of branching such that it's unclear whether we have any particular HEAD. Forums threads and mailing lists are good examples. In these cases, we might eschew mutable HEAD words and instead focus on monotonically adding new words. 

        @forum:foo {&forum}(initalize forum)
        @thread:1 {%forum:foo}(command adds thread OP to forum)
        @thread:2 {%thread:1}(command adds content to thread 1)
        @thread:3 {%thread:1}(command adds content to thread 1, second child)

A reverse lookup index would find replies to a given thread, etc.. We could compute and render value or type information for each post in the thread.

Alternative patterns might be appropriate for other application types. Regardless, by encoding all relevant application state in the dictionary, we get a lot of benefits for easy sharing, refactoring, live coding, automatic testing. Dictionary applications allow AO dictionaries to serve as whole ecosystems. This is a motivating aspect for the design of Awelon Object language.

## Development 

### Static Analysis

Though ABC doesn't specify a type system, it is designed to support static analysis. An AO dictionary under development should undergo continuous static analysis such that developers are always aware of potential issues - obvious type errors, non-termination, linter warnings, etc.. 

### Transitory Undefined Words

A dictionary in a transitory state of development will frequently have a few undefined words. These can serve a useful role in the development context: a development environment can recognize these as 'holes'. The types of a hole can be inferred from usage contexts and unit tests. The environment could help developers find an implementation. Or, at the very least, the temporary presence of undefined words will simplify top-down development. 

### DVCS Based Distribution

PLs today widely use package based distribution models. A package of code includes data types and functions, and may depend on other packages of code, all independently developed and versioned. Package based distribution introduces many complications: version conflicts, configuration management, external configuration languages. These complications hinder efforts to refactor, abstract, test, live-code, model application state in code, etc. across multiple packages. 

AO favors a far more simple and robust technique: a dictionary contains all dependencies, all words defined. DVCS-based forks and merges are readily applied: developers can fork public dictionaries, update as needed, validate changes, and cherry-pick functions or updates to push back upstream atomically. Instead of packaged libraries, every dictionary is a wholistic ecosystem. 

*Aside:* An interesting possibility is genetic programming. Words can serve as genes, definitions as alleles. Based on random word-level merges and swaps, we can get something akin to sexual recombination. This is feasible because dictionaries contain all the relevant code... much like DNA.

### Regarding Large Definitions

Definitions can potentially grow very large, especially with embedded texts or with dictionary applications. However, huge definitions are not recommended, as they hinder incremental computations, reuse, memory management. Developers may receive warnings for definitions larger than some heuristic threshold, e.g. one megabyte. Dissolving large definitions into several smaller ones isn't especially difficult, e.g. due to the concatenative structure of AO.

## Constraints on Words and Definitions

Words are constrained to be friendly in context of URLs, English text delimiters, and HTML. Tokens are constrained for purity and portability. Texts are constrained to avoid conversion errors (e.g. HTML CRLF conversions, or UTF-8 vs. UTF-16). 

Summary of constraints:

* words are limited to:
 * ASCII if alphabetical, numeral, or in -._~!$'*+:@
 * other UTF-8 except for C1, surrogates, replacement char
 * must not start with a digit or +-. followed by a digit
 * must not end with a . (dot or period)
 * no empty words or enormous words. 1..64 bytes UTF-8.
* tokens are limited to:
 * word dependencies (`{%dupd}{%swap}`)
 * discretionary value sealer (`{:foo}`)
 * discretionary value unsealer (`{.foo}`)
 * annotations (`{&static}{&copyable}`)
 * token modulo prefix is valid word
* texts are limited to:
 * exclude C0 (except LF), DEL, C1
 * exclude surrogate codepoints U+D800..U+DFFF
 * exclude replacement char U+FFFD
