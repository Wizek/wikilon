# Awelon Object Language (AO)

Awelon Object (AO) language directly uses [Awelon Bytecode (ABC)](AboutABC.md) as a foundation for functional programming. 

AO is very simple. The primary structure is the dictionary, which defines a finite set of words. Definitions are encoded in Awelon Bytecode and may refer to other words in the dictionary via `{%word}` tokens. The meaning of a word token is, trivially, to substitute the word's definition. Dependencies between words form a directed acyclic graph, thus a complete expansion of AO code results in a finite string of bytecode. 

Instead of conventional syntax, AO assumes human developers will use editable views to manipulate dictionary code. Directly reading or writing bytecode would be intolerable, but views can be rich and problem specific. See *Editable Views of Bytecode* and *Dictionary Applications*, below. Views may be implemented by a development environment, a web service, or a FUSE adapter.

## Import/Export

AO specifies a simple **.ao** file format for import and export. 

A trivial example dictionary:

        @swap rwrwzwlwl
        @swapd rw {%swap} wl
        @swapd.doc "x y z -- y x z
         swap just under the top stack element
         assuming typical (stack*ext) environment
        ~l

This is format suitable for simple text files and streams. Each word definition starts at `@` at the beginning of a line, followed by the word, followed by SP or LF, then the definition in ABC. This is unambiguous: ABC never includes `@` at the beginning of a line. A lot of words will use just one line in the file.

There are two additional structural constraints:

* well defined words are listed before use
* words are listed no more than once

These constraints are to simplify stream-processing of a large dictionary, e.g. compiling or typechecking as we go. When we encounter an unlisted word, we know that the word is not well defined (i.e. it's either undefined or part of a cycle). Because words are listed at most once, we don't need to deal with edits and recomputation.

Use file suffix **.ao**, or `text/vnd.org.awelon.aodict` in context of an HTTP transfer. 

## Programmable Views

### Editable Views of AO Bytecode

An example editable view is the [Command Language for Awelon (claw)](CommandLine.md), which provides a Forth-like experience optimized for command-line or REPL oriented programming. Claw supports numbers (integers, ratios, decimals), words, and small texts. For example, `2/3` expands to `2 3 ratio` which ultimately expands to bytecode `#2{%int}#3{%int}{%ratio}`. The expansion is reversible, bi-directional. When reading the generated bytecode through a claw view, the developer will see `2/3`.

It is possible to extend claw with structured programming features. Code of form `[cond] [body] while_do_` could be recognized and presented as a conventional while-do loop. We can take inspiration from XML, problem-specific languages, or something more esoteric. Modeling monadic bindings and DSLs is feasible. For interactive environments or live coding we might be interested in programming with widgets, e.g. `30/100 slider` might be rendered as a slider widget at 30 with an implicit domain 0..100 (from the denominator). Stateful widgets - sliders, checkboxes, radio buttons, color pickers, canvases, graphs, etc. - are generally a good fit for interactive source code.

Editable views needn't be extensions of claw, of course. Though, for user convenience, it's preferable to make most extensions compatible with a claw view. It's easy enough to use a set of flags to enable or disable certain extensions.

Alternatively, we can move beyond parsing and editing structure within a string of bytecode and focus instead on dictionary-level structures between words. This can allow us to render and manipulate *semantic* content - embedded databases and graphs and objects - rather than local syntactic structure. See *Dictionary Applications and Objects* below.

### Dictionary Applications

A dictionary application is an application whose state is hosted within a healthy dictionary. See [Wikilon's application model](ApplicationModel.md) for the detailed exploration of this idea. The short version: application state is modeled in the dictionary, applications help users view and edit the dictionary in certain ways (e.g. as a forum or spreadsheet), and external software agents can integrate real-world effects or reflection where we need them. 

Dictionary applications naturally support portability, persistence, versioning, undo, refactoring, incremental computation, caching, continuous testing, live coding, and RESTful designs (external agents pulling information or pushing updates). Low-latency applications are feasible with long-polling or subscription models. 

Dictionary applications together with long-polling or subscription is capable of modeling almost any application. Documents, databases, REPL sessions, multi-user dungeons, etc. are all viable. A few relevant patterns are discussed under [Wikilon's application model](ApplicationModel.md). With cache-friendly update patterns, performance may be acceptable.

Many dictionary applications are amenable to *extraction*, e.g. cross-compiling application objects for an Android phone or JavaScript+DOM. An extraction service is effectively another dictionary application. Extraction of dictionary applications *in media res* supports an implicit debug mode, automatic testing of old application sessions, interactive construction of applications from prototypes, and fulfills the role of conventional applications compilers.

## Development 

### Static Analysis

Though ABC doesn't specify a type system, it is designed to support static analysis. An AO dictionary under development should undergo continuous static analysis such that developers are always aware of potential issues - obvious type errors, non-termination, linter warnings, etc..

Static analysis can be greatly extended by use of *annotations*, which may potentially assert properties that would be difficult to express otherwise - e.g. that two blocks are equivalent, or that a function is commutative or associative or idempotent, or that one function is the reverse of another, or that a value should be computed statically.

### DVCS Based Distribution

PLs today widely use package based distribution models. A package of code includes data types and functions, and may depend on other packages of code, all independently developed and versioned. Package based distribution introduces many complications: version conflicts, configuration management, external configuration languages. These complications hinder efforts to refactor, abstract, test, live-code, model application state in code, etc. across multiple packages. 

AO favors a far more simple and robust technique: a dictionary contains all dependencies, all words defined. DVCS-based forks and merges are readily applied: developers can fork public dictionaries, update as needed, validate changes, and cherry-pick functions or updates to push back upstream atomically. Instead of packaged libraries, every dictionary is a wholistic ecosystem. 

*Aside:* An interesting possibility is genetic programming. Words serve as genes, definitions as alleles. Fitness can be based on typechecking, unit tests, and score annotations within each dictionary. Take a population of dictionaries and use word-level random merges (and rare mutations) to model sexual recombination. This would be expensive, but reasonably straightforward.

### Leveraging Undefined Words

A dictionary in a transitory state of development will frequently have a few undefined words. These can serve a useful role in the development context: a development environment can recognize undefined words as 'holes'. The type for a hole may be inferred from usage. A good developoment environment should help developers find implementations of this type. The number of undefined words should generally be limited based on the amount of active development, and only certain approaches to development will use them (e.g. top-down).

### Regarding Large Definitions

Definitions can potentially grow very large, especially when containing embedded texts or with dictionary applications. However, huge definitions are not recommended, as they hinder incremental computations, reuse, memory management. At the moment, I'm not suggesting any hard caps for definition sizes, but raising some warnings or flags for very large definitions is recommended. A host may compress very large definitions to mitigate the issue.

## Constraints on Words and Definitions

Words are constrained to be friendly in context of URLs, English text delimiters, and HTML. Tokens are constrained for purity and portability. Texts are constrained to avoid conversion errors (e.g. HTML CRLF conversions, or UTF-8 vs. UTF-16). 

Summary of constraints:

* words are limited to:
 * ASCII if alphabetical, numeral, or in -._~!$'*+:
 * other UTF-8 except for C1, surrogates, replacement char
 * must not start with a digit or +-. followed by a digit
 * must not terminate with a . or : (period or colon)
 * no empty words or enormous words. 1..64 bytes UTF-8.
* tokens are limited to:
 * word dependencies (`{%dupd}{%swap}`)
 * discretionary value sealer (`{:foo}`)
 * discretionary value unsealer (`{.foo}`)
 * annotations (`{&static}{&copyable}`)
 * token modulo prefix is valid word
* texts are limited to:
 * exclude C0 (except LF), DEL, C1
 * exclude surrogate codepoints U+D800..U+DFFF
 * exclude replacement char U+FFFD
