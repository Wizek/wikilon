
# Human Editable Views for AO

[Awelon Object (AO)](AboutAO.md) code can be directly read and manipulated by humans, but is not optimized for direct human use. Humans should instead manipulate AO through an editable view - an efficient and aesthetic representation of code that may be edited in place then converted back to bytecode for storage. 

This idea is essentially an instance of [projectional editing](http://martinfowler.com/bliki/ProjectionalEditing.html). The AO dictionary is our storage representation. The editable view of code would be provided by a service - e.g. a web service or a [filesystem in userspace](https://en.wikipedia.org/wiki/Filesystem_in_Userspace) adapter.

This document starts with a concrete example of a useful, purely textual, editable view named Claw. From there I generalize to more robust, expressive, portable, optionally graphical, user-defined views.

## Command Language for Awelon (Claw)

Claw is a Forth-like editable view of AO designed for plain text input in a REPL-like or command line scenario. 

Like Forth, Claw doesn't scale nicely beyond about fifteen tokens for a definition, at least without an IDE that can print inferred types or examples in a connected pane (it's otherwise too easy to lose track of context). But, also like Forth, it's easy to factor large functions into small definitions.

Claw optimizes for:

* number data `42 -7 2/3 3.141 2.998e8`
* inline texts `"hello, world!"`
* AO dictionary words `foo swap bar`

Numbers in Claw receive the bulk of attention:

        42      ==   #42 int
        -7      ==   7 negate
        2/3     ==   2 #3 ratio
        95/100  ==   95 #100 ratio
        3.141   ==   3141 #3 decimal
        -2.7    ==   -27 #1 decimal
        0.0010  ==   10 #4 decimal
        2.998e8 ==   2.998 8 exp10

Natural numbers can also be expressed easily, just use prefix `#` as in `#42`. This will result in code `#42` inlined into the output bytecode.

Inline texts have simple constraints. They may not contain double quote or LF, and we'll follow them with `lit`. Multi-line texts are the same as in ABC but require an additional blank line at the start to both simplify alignment and indicate they are not inline texts. As such, `"hello, world!"` shall desugar as:

        "
         hello, world!
        ~ lit

Words are trivially expanded into their token forms, i.e. `foo` to `{%foo}`. If a word would be ambiguous, it must be expressed in token form, e.g. `{%42}`. 

Claw also supports `[blocks]`, `{tokens}`, and command sequences `(foo,bar,baz)`. Blocks are just normal ABC blocks albeit containing Claw code, instead. Tokens are unmodified and inlined directly (and developers are encouraged to tuck a token behind a word if it's a common thing). Command sequences generalize on texts to model interactive streaming behavior or coroutines:

        (foo,bar,baz) == [[foo] (bar,baz) y]
        (baz)         == [[baz] ~ y]

Command sequences are potentially useful in a variety of scenarios, effectively providing continuation passing style and interactive streams that might be used to model problem specific command languages.

As an editable view, all Claw translations are *bidirectional*. We rewrite towards Claw representations on render, and rewrite to AO on store. A consequence is that Claw code is not always preserved exactly, e.g. if you input `2 #3 ratio` we'll store that as `#2{%int}#3{%ratio}` and later read that as `2/3`. 

Claw also ensures that a round-trip conversion starting from AO code is lossless. This is achieved by escaping AO whitespace by adding extra whitespace in Claw, i.e. `SP` in AO becomes `SP SP` in Claw. This can be useful for isolating Claw rewrites. 

## Desired Features

Features that humans deserve, and that Claw lacks. 

### Evaluable Views

Claw was designed for an earlier version of AO and ABC, before rewriting semantics and preservation of link structure. AO now has a nice property where we can evaluate from `AO → AO`, with the same dictionary. Optimally, we should also view the evaluated AO code as Claw and treat output equally as `Claw → Claw`.

Unfortunately, use of words like `ratio` and `decimal` will not reliably be generated by our evaluator. 

To make our Claw useful even for evaluated results, we must adapt it to the accelerated representations, which depends on our accelerated dictionary. The easiest approach is to define Claw within our dictionary, rather than leave it to the local runtime.

### Comments

I did not originally include comments in Claw because I favor the path of least resistance to be external documentation resources, such that developers define `foo.doc` and a few examples. However, representing comments is not difficult, and they may serve a useful role for large values. Consider:

        /* this is a comment */   
            
            (desugars to)    

        "
          this is a comment 
        ~ {&a2} {@rem} d

A model of comments including arity annotations model of comments is compatible with the *Evaluable Views* goal because we can construct comments at runtime, comment values, etc.. and can leverage comments for active debugging (e.g. conditional breakpoints or logging). 

### Local Namespaces?

Claw requires developers explicitly distinguish `trie:insert` vs. `avl:insert`. Unfortunately, this results in verbose code. It hinders both reading and writing of code when the `trie:` prefix *should* be obvious in context.

Conventionally, this problem might be addressed by namespaces. Within a namespace, words use local definitions unless there isn't one, in which case it may move to a list of 'using' imports.

Unfortunately, conventional namespaces are problematic. Import lists easily become a form of boiler-plate. Words must be resolved through non-local reflection on the codebase (which violates a bunch of locality principles). Ambiguities can be introduced asynchronously, as words are introduced. An editable view could avoid that last problem (viewing against a snapshot of the dictionary), but I'd prefer to also avoid boiler-plate and general reflection.

Namespaces without ambiguity are possible with qualified words. For example, `trie:insert` might be reduced to `t/insert` in a local scope. This isn't ideal. But it's simple to express (e.g. with a specialization on comments) and it could be a win for larger context names. If some data can be taken from a non-local scope (e.g. edit session or user data) we might also support namespaces without boiler-plate lists.

This problem might be addressed more generally via *Adaptive Syntax* mechanisms. 

### Adaptive Syntax

While a Forth-like notation is broadly useful, it isn't optimal for all problems. For example, simple polynomial math becomes a mess of copies, adds, and multiplies.

### Visual or Graphical 

### Error Handling

Humans will provide erroneous input. Not just at the parser layer, either - we can have code that fails to evaluate or typecheck, or causes tests to fail. So a question is how to handle edit-time errors. One option is to reject the code at edit time, forcing immediate resolution. Another is to allow the erroneous code, perhaps recording it as an error object, something like:

                ["[foo" {%viewToAO}]{&error}i

When we view this again, we might recognize the error construct and replace it by `[foo` as we originally input. This option seems useful, and potentially permits parsing and evaluation with only partial errors. More importantly, it unifies error handling. Parse errors are handled the same as other errors.



