@prelude "
 Awelon is a purely functional concatenative combinator based
 programming language evaluated by local, confluent rewriting.

 This is an Awelon dictionary that attempts to document Awelon
 well enough for a human to reimplement it if necessary, and
 serve as a seed for a larger dictionary.
"
@prim: "Awelon language primitives"
@prim:a "[B][A]a == A[B]   (apply)"
@prim:b "[B][A]b == [[B]A] (bind)"
@prim:c "   [A]c == [A][A] (copy)"
@prim:d "   [A]d ==        (drop)"
@prim:blocks "
 Blocks

     [code goes here]

 Blocks are the values of Awelon. They represent first class
 functions. Semantically, all values in Awelon blocks, even
 natural numbers and texts.

 An Awelon runtime or compiler will recognize and optimize
 a useful subset of values, effectively elevating them to
 to primitive performance features. This is acceleration.

 An Awelon development environment can effectively extend
 Awelon syntax via editable views, for example `4/10` may
 expand to `[4 10 ratio]` in source. Even local variables
 and lambdas be supported this way.
"
@prim:numbers "
 Natural Numbers

     42 = [41 S]

 Natural numbers in Awelon are encoded in base 10. Predefined
 number words use regex `[1-9][0-9]*`. Definitions of `0` and
 `S` are left to the user, but accelerated definitions should
 be favored for performance.

 Awelon does not directly support other number types, but use
 of editable views can provide syntax for integers, rationals,
 decimals, and even vectors or matrices.
"
@prim:texts "
 Embedded Texts

     "hello" = [104 "ello" :]
     ""      = ~

     "
      multi-line texts start with `" LF` (34 10)
      non-empty lines are indented one space (32)
      text terminates with final `LF "` (10 34)
     "

 Texts must be encoded in valid UTF-8 excluding C0 (0-31) and
 DEL (127), excepting LF (10). Inline texts cannot contain LF
 or " (10 or 34). Indentation after LF is the only escape.

 Semantically each text encodes a list of natural numbers, one
 element per Unicode codepoint. Definitions of `:` (cons) and
 `~` (nil) are left to the user, but accelerated definitions are
 recommended for performance.
"
@prim:words "
 Awelon Words

     [B][A]w == [A][B]   w = (a2) [] b a     (swap)
     [A]i == A           i = [] w a d        (inline)
     [X][F]z == [X][[F]z]F                   (fixpoint)
        z = [[(a3) c i] b (=z) [c] a b w i] (a3) c i

 Words are defined in context of a dictionary, the Awelon
 codebase, with a few exceptions like natural numbers.

 The semantics for Awelon words are trivial: lazily inline
 word's definition. By lazily, I mean we only inline if it
 results in further rewrites. We preserve human meaningful
 structure where feasible, and maximize structure sharing.
 Use of arity annotations like (a2) and (a3) are valuable
 to help control lazy linking.

 Syntactically, words consist of a sequence of characters
 excluding a short blacklist:

     @#()<>{}\/,;|&='", SP, C0, and DEL (0-32 and 127)

 See `prim:hierarchy` for namespaces.
"
@prim:dictionary "
 Awelon Dictionary

     secureHashOfPatchA
     secureHashOfPatchB
     @word1 definition1
     @word2 definition2
     ...

 An Awelon codebase is called a dictionary. A dictionary defines
 a set of words, and is self-contained. Awelon specifies a patch
 based representation for constructing large dictionaries, using
 secure hashes to reference other patches and support incremental
 import and export, indexing, and structure sharing.

 The initial patches are logically inlined. The last definition
 of a word is the one we use. To logically drop a word, we use
 `@foo foo` to define a trivial cycle. Normally, cycles are an
 error. Awelon code uses explicit fixpoints for cyclic behavior.

 See `prim:hierarchy` for hierarchical structure.
"
@prim:hierarchy "
 Hierarchical Dictionaries, Namespaces, and Localization

     ... in body of dictionary ...
     @@dict1 secureHashOfDict1
     @@dict2 secureHashOfDict2
     @word1  [42 foo]@dict1 bar@dict2
     ...

 Hierarchical dictionaries are represented by defining symbol
 `@dict` with a secure hash referencing a dictionary patch.
 Like a word, this symbol may be redefined by later patches.

 Words in a hierarchical dictionary can be referenced using
 a hierarchical namespace qualifier, like `bar@dict`. A full
 block may be qualified: `[42 foo]@d` means `[42@d foo@d]`.
 But these qualifiers are second-class, and no whitespace is
 allowed between the word or block and the `@d` qualifier.

 There is no means for a dictionary to reference its parent.
 Thus, each dictionary must be self-contained and will often
 replicate a lot of definitions. Fortunately, secure hashes
 support structure sharing among hierarchical dictionaries.

 Localization is an optimization: when a namespace qualifier
 does not affect meaning, we may drop the qualifer. If `42@d`
 behaves as `42`, we should favor `42`. Localization is good
 for both performance and aesthetics.
"
@prim:annotations "
 Annotations in Awelon

     (nat)    assert value is natural number
     (nc)     assert value is not copied later
     (trace)  record value to a debug log
     (par)    request parallel evaluation of value
     (a3)     arity three, wait for three args
     (jit)    request runtime to compile code
     (=z)     replace [definition of z] by [z]
     (stow)   [large value] => [$secureHash]

 Annotations are represented by parenthetical symbols and adjust
 how Awelon code is processed. Annotations can impact performance,
 support debugging, cause incorrect programs to fail fast, affect
 aesthetics, and provide rendering hints for editable views.

 Annotations must have identity semantics in a formal sense, such
 that erasing them doesn't modify meaning or observable behavior
 within a computation. They extend Awelon within that limit.

 Supported annotations are documented under prefix `anno:`.
"
@prim:acceleration "
 Acceleration of Awelon

 Example. A typical model of natural numbers is:

     type Nat = Zero | Succ Nat

 This model has nice formal properties, but its direct use in
 computation is inefficient. Conventional languages might add
 a primitive number type for performance. Awelon aims instead
 to recognize a few such models and accelerate them, using a
 specialized representation and a few optimized operations.

 Acceleration of numbers, records, and arrays would cover many
 conventional languages. It is feasible to further accelerate
 linear algebra via GPGPUs or process networks via the cloud.
 A few carefully chosen models cover many performance cases.

 Accelerated models effectively become performance primitives,
 even if not semantic ones. Awelon relies on this technique.

 Effective use of accelerated models requires they are stable,
 predictable, reliable. As a convention, we define `foo.accel`
 to document that `foo` should be accelerated. Awelon systems
 can robustly verify these documented assumptions.
"
@prim:secureHash "
 Secure Hash Resources

     secureHashOfPatch
     @b %secureHashOfBinary
     @c $secureHashOfCode
     @@d secureHashOfDict

 Awelon leverages secure hashes to reference immutable binary
 resources. At the dictionary layer, Awelon uses secure hashes
 for patches and hierarchical structure. Within code, binary
 and function values may be referenced via secure hash.

 Stowage - [large value](stow) => [$secureHash] - saves data
 and lazily links it via secure hashes. This enables Awelon
 to model larger than memory data, effect-free LSM-trees.

 A more obvious use case is binaries - injecting sound files,
 textures, or similar structures into an Awelon computation.
 Secure hashes are more convenient and efficient than base64.

 An Awelon system essentially operates in a larger environment
 where secure hashes are defined, shared among dictionaries.
 The hash is a secure capability, authorizing read access.

 The secure hash chosen: 360-bit BLAKE2b encoded in base64url.
"
@anno: "assumed annotations"
@anno:arity "
 Arity Annotations (a2)..(a9)

        [B][A](a2) == [B][A]
     [C][B][A](a3) == [C][B][A]

 Arity annotationss prevent access to values at their left until
 the requisite number have been provided. The annotation is then
 erased and computation continues.

 Arity annotations support lazy evaluations, inline comments of
 form `[comment](a2)d`, and help control lazy linking of words.
 They are among the most versatile and useful of annotations.
"
@anno:substructure "
 Substructural Type Annotations (nc) and (nd)

 Substructural type systems make assertions about whether a value
 may be copied or dropped. They are useful for modeling resources
 and protocols where values represent obligations.

 Annotation (nc) marks a value no-copy, (nd) no-drop. This offers
 a simple basis for affine (nc), relevant (nd), and linear (both)
 data types, readily verified statically or dynamically.
"
@prelude.runtime "Wikilon"
@prelude.version "2017 Feb 22"
